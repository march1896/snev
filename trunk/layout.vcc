// *****************************************************************************
//
// Layout.vcc
//
// Layout module - layouts are generated in GUI layout tool, loaded in the game
//                 as layout resources.  This module provides routines to
//                 display a layout, as well as accessors to be used by
//                 custom-draw layout menus.
// NOTES:
//
//	o Parallel View:
//		The Near Plane is at 599, the Far Plane is at -400
//
// (c) 2003 Visual Concepts
// by Isaac Gartner
//    Nick Jones
//
// *****************************************************************************

#include "layout.h"
#include "layoutresource.h"
#include "markscene.h"
#include "marksceneresource.h"
#include "gui.h"
#include "view.h"
#include "callback.h"


//*****************************************************************************
//
// Module data
//
//*****************************************************************************

#ifdef VCFETARGET
struct LAYOUT_RESOURCE
{
	VCRESOURCE_CONTEXT			Context;
	LAYOUT_RESOURCE*		    Prev;
	LAYOUT_RESOURCE*			Next;
};

static struct
{
	LAYOUT_RESOURCE* Resource = null;
} LayoutData = {...};

#endif

//*****************************************************************************
//
// Public functions
//
//*****************************************************************************

#ifdef LAYOUTVIEWER
void Layout_SetDrawSpreadsheetCallback( LAYOUT* Layout, LAYOUT_SPREADSHEET_FUNC* CallbackFunction )
{
	Layout->DrawSpreadsheetCallback = CallbackFunction;
}
#endif


//*****************************************************************************
//
//  Store then modify bone translation value for modified bones
//  This is done to avoid modifying bones repeatedly thus causing them to fly away
//  into the Great Unknown
//
//*****************************************************************************
static void LayoutScene_SaveBoneOffsets( LAYOUT_SCENE* LayoutScene )
{
	u8* BoneModifierRaw = (u8*)LayoutScene->BoneModifierList;
	if ( BoneModifierRaw == null ) return;
	for ( uint i = 0 ; i < LayoutScene->BoneModifierCount; i++, BoneModifierRaw+=sizeof(LAYOUT_BONE_MODIFIER) )
	{
		BoneModifierRaw = alignup(BoneModifierRaw,alignof(LAYOUT_BONE_MODIFIER));
		LAYOUT_BONE_MODIFIER* BoneModifier = (LAYOUT_BONE_MODIFIER*)BoneModifierRaw;

		if ((u32)(BoneModifier->ObjectNameHash)!=0) continue; //unprocessed bone-modifier
		matrix* BoneMatrix = (matrix*)(u32)BoneModifier->SceneNameHash;
		if ( BoneMatrix==null ) continue; //Ignore erroneous bone-modifiers

		BoneModifier->Offset.set_z( BoneMatrix->tx );
		BoneModifier->Offset.set_w( BoneMatrix->ty );
		BoneMatrix->tx+= BoneModifier->Offset.get_x();
		BoneMatrix->ty+= BoneModifier->Offset.get_y();
	}
}

//*****************************************************************************
//
//  Restore bone translation values for modified bones
//
//*****************************************************************************
static void LayoutScene_RestoreBoneOffsets( LAYOUT_SCENE* LayoutScene )
{
	u8* BoneModifierRaw = (u8*)LayoutScene->BoneModifierList;
	if ( BoneModifierRaw == null ) return;
	for ( uint i = 0 ; i < LayoutScene->BoneModifierCount; i++, BoneModifierRaw+=sizeof(LAYOUT_BONE_MODIFIER) )
	{
		BoneModifierRaw = alignup(BoneModifierRaw,alignof(LAYOUT_BONE_MODIFIER));
		LAYOUT_BONE_MODIFIER* BoneModifier = (LAYOUT_BONE_MODIFIER*)BoneModifierRaw;

		if ((u32)(BoneModifier->ObjectNameHash)!=0) continue; //unprocessed bone-modifier
		matrix* BoneMatrix = (matrix*)(u32)BoneModifier->SceneNameHash;
		if ( BoneMatrix == null ) continue;

		BoneMatrix->tx = BoneModifier->Offset.get_z();
		BoneMatrix->ty = BoneModifier->Offset.get_w();
	}
}

//*****************************************************************************
//
//
//
//*****************************************************************************

static void LayoutScene_SetState( LAYOUT_SCENE* LayoutScene, LAYOUT_SCENE_STATE State )
{
	VCSCENE* Scene;

	assert_pointer( LayoutScene );

	Scene = LayoutScene->Scene;
	
	if (Scene == null) return;

	if ( LayoutScene->AnimationMode == MULTISTATE )
	{
		switch ( State )
		{
			case START:
				// Set scene to the beginning
				LayoutScene->Time = LayoutScene->StartTime;
				break;

			case SECTION2:
				// Set scene to the beginning of the loop
				LayoutScene->Time = LayoutScene->LoopStartTime;
				break;

			case SECTION3:
				// Set scene to the end of the loop
				LayoutScene->Time = LayoutScene->LoopEndTime;
				break;

			case END:
				LayoutScene->Time = LayoutScene->EndTime;
				break;
		}
	}
	else
	{
		// Non-multistate animations only have a beginning and an end
		switch( State )
		{
			case START:
				// Set scene to the beginning
				LayoutScene->Time = LayoutScene->StartTime;
				break;

			case SECTION2:
			case SECTION3:
			case END:
				LayoutScene->Time = LayoutScene->EndTime;
				State             = END;
				break;
		}
	}
	LayoutScene->State = State;

	//update immediately.
	LayoutScene_RestoreBoneOffsets(LayoutScene);
	VCScene_SetTimeInSeconds( LayoutScene->Scene, LayoutScene->Time );
	LayoutScene_SaveBoneOffsets(LayoutScene);
}


//*****************************************************************************
//
//
//
//*****************************************************************************

void LayoutScene_SetEnabled( LAYOUT_SCENE* LayoutScene, bool Enabled ) {
    assert_pointer( LayoutScene );

    LayoutScene->Enabled = Enabled;
}


//*****************************************************************************
//
//
//
//*****************************************************************************

VCSCENE* LayoutScene_GetScene( LAYOUT_SCENE* LayoutScene )
{
    assert_pointer( LayoutScene );
    return( LayoutScene->Scene );
}


//*****************************************************************************
//
//  Advance the State of the layout scene.  Used to advance past the looping phase
//  of MULTISTATE animations, or to re-start an animation
//
//*****************************************************************************

static void LayoutScene_AdvanceState( LAYOUT_SCENE* LayoutScene )
{
	if ( LayoutScene->State != END )
	{
		LayoutScene->State++;
	}
	else
	{
		LayoutScene->State = START;
	}

	LayoutScene_SetState( LayoutScene, LayoutScene->State );
}



//*****************************************************************************
//
//  Set the State of the layout
//
//*****************************************************************************

static void Layout_SetState( LAYOUT* Layout, LAYOUT_SCENE_STATE State )
{
	LAYOUT_OBJECT*   LayoutObject;
	LAYOUT_TEMPLATE* LayoutTemplate;

	assert_pointer( Layout );

	for ( LayoutObject = Layout->ObjectList  ;  LayoutObject  ;  LayoutObject = LayoutObject->Next )
	{
		switch( LayoutObject->Type )
		{
			case SCENE:
				LayoutScene_SetState( (LAYOUT_SCENE*) LayoutObject, State );
				break;

			case TEMPLATE:
				LayoutTemplate = (LAYOUT_TEMPLATE*) LayoutObject;
				Layout_SetState( LayoutTemplate->Layout, State );
				break;

			case SPREADSHEET:
				// spreadsheets currently have no state information
				break;
			
			case ANIMATION:
				// animations currently have no state information
				break;
		}
	}
}


//*****************************************************************************
//
//  Advance the State of the layout
//
//  Animations have multiple states.
//    Simple animations have two states:
//       START   : the beginning of the animation
//       END     : the last frame of the animation
//
//    Multi-state animations have
//       START     : the initial frames, before the looping section
//       SECTION2  : the frames from LOOP_START_FRAME to LOOP_END_FRAME
//       SECTION3  : the frames from LOOP_END_FRAME to the end
//       END       : the last frame of the animation
//
//   When the state of a scene is set, the scene time is set to the
//   first frame of the specified state.  Advancing the state goes to the next
//   state.  Simple animations will skip over SECTION2 and SECTION3, so if
//   you advance from START, it will go to END.  Similarly, if you advance from
//   END you will go to START.
//
//*****************************************************************************

void Layout_AdvanceState( LAYOUT* Layout )
{
	LAYOUT_OBJECT*   LayoutObject;
	LAYOUT_TEMPLATE* LayoutTemplate;

	assert_pointer( Layout );

	for ( LayoutObject = Layout->ObjectList  ;  LayoutObject  ;  LayoutObject = LayoutObject->Next )
	{
		switch( LayoutObject->Type )
		{
			case SCENE:
				LayoutScene_AdvanceState( (LAYOUT_SCENE*) LayoutObject );
				break;

			case TEMPLATE:
				LayoutTemplate = (LAYOUT_TEMPLATE*) LayoutObject;
				Layout_AdvanceState( LayoutTemplate->Layout );
				break;

			case SPREADSHEET:
				// spreadsheets currently have no state information
				break;
			
			case ANIMATION:
				// animations currently have no state information
				break;
		}
	}
}


//*****************************************************************************
//
//  Update animation for a LAYOUT_SCENE
//
//  Note: this function duplicates some of the functionality of VCScene_Update
//  The reason for not calling VCScene_Update is that we want to be able to
//  animate the same scene independently for multiple instances, so we have
//  to keep track of the scene time within LAYOUT_SCENE
//
//*****************************************************************************

static void LayoutScene_Update( LAYOUT_SCENE* LayoutScene, float DeltaTime )
{
	float AnimStartTime, AnimEndTime; // fixed XBOX precision bug

	assert_pointer( LayoutScene  );

	if ( LayoutScene->AnimationMode == NONE ) return;

	if ( LayoutScene->AnimationMode == USER )
	{
		LayoutScene_RestoreBoneOffsets(LayoutScene);
		VCScene_SetTimeInSeconds( LayoutScene->Scene, LayoutScene->Time );
		LayoutScene_SaveBoneOffsets(LayoutScene);
		return;
	}

    AnimStartTime = LayoutScene->StartTime;
	AnimEndTime   = LayoutScene->EndTime;

    if (AnimStartTime > AnimEndTime) {
		LayoutScene->Time -= DeltaTime;
	} else {
		LayoutScene->Time += DeltaTime;
	}

    if ( LayoutScene->AnimationMode == MULTISTATE )
	{
		 if( LayoutScene->State == START && LayoutScene->Time >= LayoutScene->LoopStartTime )
		 {
			 LayoutScene->State = SECTION2;
		 }
		 if ( LayoutScene->State == SECTION2 && LayoutScene->Time >= LayoutScene->LoopEndTime )
		 {
			 LayoutScene->Time = LayoutScene->LoopStartTime + (LayoutScene->Time - LayoutScene->LoopEndTime);
		 }
	}

	bool finished = false;
	if (AnimStartTime > AnimEndTime) {
		finished = LayoutScene->Time <= AnimEndTime;
	} else {
		finished = LayoutScene->Time >= AnimEndTime;
	}

	if( finished ) {
		if ( LayoutScene->AnimationMode == LOOPING )
		{
			LayoutScene->Time = AnimStartTime + (LayoutScene->Time - AnimEndTime);
		}
		else
		{
			LayoutScene->Time  = AnimEndTime;
			LayoutScene->State = END;
		}
	}

	// I can't see how this case would happen, but just for saftey...
	//if ( LayoutScene->Time < AnimStartTime )
	//{
	//	LayoutScene->Time = AnimStartTime;
	//}

	LayoutScene_RestoreBoneOffsets(LayoutScene);
	VCScene_SetTimeInSeconds( LayoutScene->Scene, LayoutScene->Time );
	LayoutScene_SaveBoneOffsets(LayoutScene);
}


//*****************************************************************************
//
//  Update the layout -- perform animation
//
//*****************************************************************************

// debug option -- allows testing Draw() code while pausing animation.
static bool Layout_DoUpdate = true;

void Layout_Update( LAYOUT* Layout, float DeltaTime )
{

	LAYOUT_OBJECT * LayoutObject;
	LAYOUT_TEMPLATE * LayoutTemplate;
	// Scene animation has to happen at draw time (because of multiple
	// refrences to a single scene within a layout) so we temporarily store the
	// DeltaTime here, for use in the Draw() function

	assert_pointer( Layout );
	assert_message( Layout->Status == "initialized", "Layout is not initialized" );


	Layout->DeltaTime = Layout_DoUpdate ? DeltaTime : 0;

	// make sure template layouts are updated as well!

	for( LayoutObject = Layout->ObjectList  ;  LayoutObject  ;  LayoutObject = LayoutObject->Next ) {
		switch ( LayoutObject->Type ) {
			case TEMPLATE:
				// Recursively update the sub-layout
				LayoutTemplate = (LAYOUT_TEMPLATE*) LayoutObject;
				if ( LayoutTemplate->Layout ) {
					Layout_Update( LayoutTemplate->Layout, DeltaTime );
				}
				break;

			case SCENE:
			case SPREADSHEET:
			case ANIMATION:
				break;
		}
	}
}


//*****************************************************************************
//
//  Set the animation time of a layout scene
//
//*****************************************************************************

VCSCENE * Layout_GetVCScene( LAYOUT * Layout, string_crc NameHash ) {

	LAYOUT_OBJECT * LayoutObject;

	assert_pointer( Layout );
	if ( Layout == null ) return( null );

	LayoutObject = Layout_GetObject( Layout, NameHash );
	if ( LayoutObject && ( LayoutObject->Type == SCENE ) ) {
		LAYOUT_SCENE * LayoutScene = (LAYOUT_SCENE*) LayoutObject;
		return LayoutScene->Scene;
	}

	return null;
}


//*****************************************************************************
//
//  Control display of scenes within the layout
//
//*****************************************************************************

void Layout_SetSceneEnable(LAYOUT* Layout, string_crc NameHash, bool Enable)
{
	LAYOUT_OBJECT * LayoutObject;

	assert_pointer( Layout );
	if ( Layout == null ) return;

	LayoutObject = Layout_GetObject( Layout, NameHash );
	if ( LayoutObject && ( LayoutObject->Type == SCENE ) ) {
		LAYOUT_SCENE * LayoutScene = (LAYOUT_SCENE*) LayoutObject;
        LayoutScene_SetEnabled( LayoutScene, Enable );
	}
}


//*****************************************************************************
//
// force an offset for an object in a layout
//
//*****************************************************************************

void Layout_SetObjectOffset( LAYOUT* Layout, string_crc NameHash, vector4* Offset)
{
	LAYOUT_OBJECT * LayoutObject;
	assert_pointer( Layout );
	
	if ( Layout == null ) return;

	LayoutObject = Layout_GetObject( Layout, NameHash );
	if ( LayoutObject ) {
		LayoutObject->Offset = *Offset;
	}
}


//*****************************************************************************
//
//
//
//*****************************************************************************

vector4* Layout_GetObjectOffset( LAYOUT* Layout, string_crc NameHash )
{
	LAYOUT_OBJECT * LayoutObject;
	assert_pointer( Layout );
	
	if ( Layout == null ) return null;

	LayoutObject = Layout_GetObject( Layout, NameHash );
	if ( LayoutObject ) {
		return( &LayoutObject->Offset );
	}

	return null;
}


//*****************************************************************************
//
// Get layout object
//
//*****************************************************************************

LAYOUT_OBJECT* Layout_GetObject( LAYOUT* Layout, string_crc NameHash )
{
	LAYOUT_OBJECT * LayoutObject;

	assert_pointer( Layout );
	if ( Layout == null ) return( null );

	for ( LayoutObject = Layout->ObjectList; LayoutObject;  LayoutObject = LayoutObject->Next )
	{
		if ( LayoutObject->NameHash == NameHash ) {
			return( LayoutObject );
		}
	}

	return( null );
}


//*****************************************************************************
//
// Get layout scene
//
//*****************************************************************************

LAYOUT_SCENE * Layout_GetScene( LAYOUT * Layout, string_crc NameHash )
{
	LAYOUT_OBJECT * LayoutObject = null;

	LayoutObject = Layout_GetObject( Layout, NameHash );
	if ( LayoutObject       == null  ) return( null );
	if ( LayoutObject->Type != SCENE ) return( null );

	return( (LAYOUT_SCENE *) LayoutObject );
}


//*****************************************************************************
//
// Get layout animation
//
//*****************************************************************************

LAYOUT_ANIMATION * Layout_GetAnimation( LAYOUT * Layout, string_crc NameHash )
{
	LAYOUT_OBJECT * LayoutObject = null;

	LayoutObject = Layout_GetObject( Layout, NameHash );
	if ( LayoutObject       == null  ) return( null );
	if ( LayoutObject->Type != ANIMATION ) return( null );

	return( (LAYOUT_ANIMATION *) LayoutObject );
}


//*****************************************************************************
//
// Get the animation time of a layout scene
//
//*****************************************************************************

float LayoutScene_GetTime( LAYOUT_SCENE* LayoutScene )
{
	if ( !LayoutScene || !LayoutScene->Scene ) return( 0 );
	return( LayoutScene->Time );
}


//*****************************************************************************
//
// Set the animation time of a layout scene
//
//*****************************************************************************

void LayoutScene_SetTime( LAYOUT_SCENE* LayoutScene, float Time )
{
	float StartTime, EndTime;

	if ( !LayoutScene || !LayoutScene->Scene ) return;

	LayoutScene->Time = Time;
	LayoutScene_RestoreBoneOffsets(LayoutScene);
	VCScene_SetTimeInSeconds( LayoutScene->Scene, LayoutScene->Time );
	LayoutScene_SaveBoneOffsets(LayoutScene);

	StartTime = LayoutScene->StartTime;
	EndTime   = LayoutScene->EndTime;

	// update state
	if ( LayoutScene->AnimationMode == MULTISTATE )
	{
		if ( Time < LayoutScene->LoopStartTime ) {
			LayoutScene->State = START;
		} else if ( Time <= LayoutScene->LoopEndTime ) {
			LayoutScene->State = SECTION2;
		} else if ( Time < EndTime ) {
			LayoutScene->State = SECTION3;
		} else {
			LayoutScene->State = END;
		}
	}
	else
	{
		LayoutScene->State = ( Time >= EndTime ) ? END : START;
	}
}


//*****************************************************************************
//
//
//
//*****************************************************************************

void Layout_SetSceneTime( LAYOUT* Layout, string_crc NameHash, float Time )
{
	LayoutScene_SetTime( Layout_GetScene( Layout, NameHash ), Time );
}


//*****************************************************************************
//
// Play an animation
//
//*****************************************************************************

void Layout_StartSceneAnimation( LAYOUT* Layout, string_crc SceneHash, string_crc AnimHash )
{
	LAYOUT_SCENE * LayoutScene     = Layout_GetScene( Layout, SceneHash );
	LAYOUT_ANIMATION * LayoutAnimation = Layout_GetAnimation( Layout, AnimHash );

	if (LayoutScene && LayoutAnimation) {

		LayoutScene->AnimationMode = LayoutAnimation->Mode;
		LayoutScene->StartTime	   = LayoutAnimation->StartFrame / 60.0;
		LayoutScene->EndTime	   = LayoutAnimation->EndFrame / 60.0;
		LayoutScene->LoopStartTime = LayoutAnimation->LoopStartFrame / 60.0;
		LayoutScene->LoopEndTime   = LayoutAnimation->LoopEndFrame / 60.0;

		LayoutScene_SetState( LayoutScene, START );
	}
}


//*****************************************************************************
//
//
//
//*****************************************************************************

void Layout_SetSceneAnimationState( LAYOUT* Layout, string_crc SceneHash, LAYOUT_SCENE_STATE State )
{
	LAYOUT_SCENE * LayoutScene = Layout_GetScene( Layout, SceneHash );

	if (LayoutScene) {

		LayoutScene_SetState( LayoutScene, State );
	}
}


//*****************************************************************************
//
// draw text overlays specified in a markscene
//
//*****************************************************************************

static void Layout_DrawSceneText( LAYOUT* Layout, const void* LayoutContext, LAYOUT_SCENE* LayoutScene, PROCESS_INSTANCE * Instance )
{
	LAYOUT_DYNAMIC_TEXT_NODE* DynamicText;
    const MARKSCENETEXT*      MarkSceneText;
	static char               Buffer[ 1024 ];
    bool                      found;
    uint                      numTexts;
	uint                      i;

	numTexts = MarkScene_GetNumberOfTexts( LayoutScene->MarkScene );
	
	for (i = 0; i < numTexts; i++) {

		MarkSceneText = MarkScene_GetTextByIndex( LayoutScene->MarkScene, i );

		if ( MarkSceneText_IsUsingSampleText( MarkSceneText ) )
		{
			MarkSceneText_Draw( MarkSceneText, "Wtf..." );
		}
		else
		{
			// is there a dynamic text entry for this node?
			found = false;

			string_crc LabelHash = MarkSceneText_GetLabelHash( MarkSceneText );

			//first try run-time callbacks (TODO: Binary search)
			CALLBACK_OBJECT* Callback = LayoutScene->TextCallback;
			while (Callback!=null)
			{
				if ( Callback->Item == (u32)LabelHash )
				{
					LAYOUT_TEXT_FUNC* Func = (LAYOUT_TEXT_FUNC*)Callback->Func;
					if ( Func!=null )
					{
						MarkSceneText_Setup( MarkSceneText );
						(*Func)( {
							LayoutContext = LayoutContext,
							User          = Callback->Param,
							User2         = Callback->Param2,
                            UserList      = Callback->UserList,
							Buffer        = Buffer,
							BufferSize    = countof(Buffer),
							MarkSceneText = MarkSceneText,
							Instance      = Instance,
							TextContext   = MarkSceneText_GetTextContext()
						} );
						MarkSceneText_DrawLayout( MarkSceneText, Buffer );
					}
					found = true;
					break;
				}
				Callback = Callback->Next;
			}

			DynamicText = Layout->DynamicText;

			if (DynamicText && !found ) {
				while (DynamicText->Func) {
					if ( (    (u32)DynamicText->SceneNameHash == 0
					       || DynamicText->SceneNameHash == LayoutScene->NameHash
						 )
						
						 &&

						 (    (u32)DynamicText->NodeNameHash == 0
						   || DynamicText->NodeNameHash == MarkSceneText_GetLabelHash( MarkSceneText )
						 )
					)
					{

						MarkSceneText_Setup( MarkSceneText );

						// Call the function specified in the table to set the string contents

						Buffer[0] = '\0';

						( *DynamicText->Func)( { LayoutContext = LayoutContext,
												 User          = DynamicText->Context,
                                                 User2         = DynamicText->Context2,
                                                 UserList      = DynamicText->UserList,
												 Buffer        = Buffer,
												 BufferSize	   = countof(Buffer),
												 MarkSceneText = MarkSceneText,
												 Instance      = Instance,
												 TextContext   = MarkSceneText_GetTextContext(),
				
											   } );
						
						MarkSceneText_DrawLayout( MarkSceneText, Buffer );
						found = true;
						break;
					}
					DynamicText++;
				}
			}
			
			// if there's no entry for this node, just display the node name
			if (!found) {
				MarkSceneText_Draw( MarkSceneText, "unknown label" );
			}
		}
	}
}


//*****************************************************************************
//
// draw a single custom node from a markscene
//
//*****************************************************************************
static void Layout_DrawSceneCustomNode ( const LAYOUT*                  Layout,
										 const MARKSCENENODE*           SceneNode,
										 const LAYOUT_CUSTOM_DRAW_SCENE SceneType,
										 const LAYOUT_SCENE*            LayoutScene,
										       PROCESS_INSTANCE*        Instance )
{
	LAYOUT_CUSTOM_DRAW_NODE* CustomDrawNode;
	matrix Matrix;
	
	// Search for a specific entry for this node
	for ( CustomDrawNode = Layout->CustomDrawNodes;
		  CustomDrawNode && CustomDrawNode->Func;
		  ++CustomDrawNode )
	{
		if ( (    (u32)CustomDrawNode->SceneNameHash == 0
			   || CustomDrawNode->SceneNameHash == LayoutScene->NameHash )
			 &&
			
			 (    CustomDrawNode->NodeName == null
			   || ( VCChecksum_StringIgnoreCase( CustomDrawNode->NodeName ) == MarkSceneNode_GetLabelHash( SceneNode ) ) )
			 &&

			 (    CustomDrawNode->SceneType == NONE
			   || CustomDrawNode->SceneType == SceneType )
		)
		{
			// Found a match, so draw the node
			MarkSceneNode_GetMatrix( SceneNode, &Matrix );
			if ( CustomDrawNode->Func ) {
				( *CustomDrawNode->Func )( { LayoutContext 	= Layout->Context,
											 User			= CustomDrawNode->Context,
                                             User2          = CustomDrawNode->Context2,
                                             UserList       = CustomDrawNode->UserList,
											 Matrix			= &Matrix,
											 Visibility		= MarkSceneNode_GetVisibility( SceneNode ),
											 Instance		= Instance
											} );
			}
		}
	}
}


//*****************************************************************************
//
//
//
//*****************************************************************************

static void Layout_ExecuteCustomNodeCallbacks(CALLBACK_OBJECT* Callback, const void* LayoutContext, PROCESS_INSTANCE * Instance )
{
	//Should the callbacks be called immediately before drawing or in a batch?
	while (Callback)
	{
		MARKSCENENODE* SceneNode = (MARKSCENENODE*)Callback->Item;
		LAYOUT_CUSTOM_DRAW_FUNC* Func = (LAYOUT_CUSTOM_DRAW_FUNC*)Callback->Func;
		if ( SceneNode!=null && Func!=null )
		{
			matrix Matrix;
			MarkSceneNode_GetMatrix( SceneNode, &Matrix );
			(*Func)( {
				LayoutContext = LayoutContext,
				User       = Callback->Param,
				User2      = Callback->Param2,
                UserList   = Callback->UserList,
				Matrix     = &Matrix,
				Visibility = MarkSceneNode_GetVisibility( SceneNode ),
				Instance   = Instance
			} );
		}
		Callback = Callback->Next;
	}
}


//*****************************************************************************
//
// draw custom nodes from a markscene
//
//*****************************************************************************

static void Layout_DrawSceneCustomNodes( LAYOUT* Layout, LAYOUT_SCENE* LayoutScene, PROCESS_INSTANCE * Instance )
{
	uint    i;

	assert_pointer( LayoutScene );

	Layout_ExecuteCustomNodeCallbacks(LayoutScene->LocatorCallback,Layout->Context,Instance);
	// Draw all Locator nodes
	for ( i = 0; i < MarkScene_GetNumberOfLocators( LayoutScene->MarkScene ); i++ )
	{
		const MARKSCENENODE * Locator = MarkScene_GetLocatorByIndex( LayoutScene->MarkScene, i );

		Layout_DrawSceneCustomNode( Layout, Locator, LOCATOR, LayoutScene, Instance );
	}

}


//*****************************************************************************
//
// update scene materials by calling user callbacks
//
//*****************************************************************************

static void Layout_SetupSceneMaterials( LAYOUT* Layout, const void* LayoutContext, LAYOUT_SCENE* LayoutScene, PROCESS_INSTANCE * Instance )
{
	LAYOUT_DYNAMIC_MATERIAL*   DynamicMaterial;
	VCMATERIAL*                Material;

	assert_pointer( Layout );
	assert_pointer( LayoutScene );

	CALLBACK_OBJECT* callback = LayoutScene->MaterialCallback;
	while (callback)
	{
		Material = (VCMATERIAL*)callback->Item;
		LAYOUT_MATERIAL_FUNC* func = (LAYOUT_MATERIAL_FUNC*)callback->Func;
		if ( Material!=null && func!=null )
		{
			(*func)( {
				LayoutContext = LayoutContext,
				User     = callback->Param,
				User2    = callback->Param2,
                UserList = callback->UserList,
				Material = Material,
				Instance = Instance
			} );
		}
		callback = callback->Next;
	}

	DynamicMaterial = Layout->DynamicMaterials;

	if ( DynamicMaterial )
	{
		while ( DynamicMaterial->Func )
		{

			if (    (u32)DynamicMaterial->SceneNameHash == 0
				 || DynamicMaterial->SceneNameHash == LayoutScene->NameHash )
			{
				Material = VCScene_GetMaterialByName( LayoutScene->Scene, DynamicMaterial->MaterialName );
				if ( Material )
				{
					( *DynamicMaterial->Func )( { LayoutContext = LayoutContext,
												  User			= DynamicMaterial->Context,
                                                  User2			= DynamicMaterial->Context2,
                                                  UserList      = DynamicMaterial->UserList,
												  Material		= Material,
												  Instance		= Instance
												} );
				}
			}
			DynamicMaterial++;
		}
	}
}


//*****************************************************************************
///////////////////// functions that should be there but arent
//  VCScene_GetMaterialByNameCrc is not exported
//
//*****************************************************************************

static VCMATERIAL* Layout_GetMaterialByNameCrc( const VCSCENE* s , string_crc NameCrc )
{
	uint u;
	assert_pointer( s );
	for( u = 0  ;  u < s->NumberOfMaterials  ;  u++ ) {
		if( NameCrc == VCChecksum_String( s->MaterialList[ u ].Name ) ) {
			return &(s->MaterialList[ u ]);
		}
	}
	return null;
}


//*****************************************************************************
//
//  Scene Callbacks
//
//*****************************************************************************

static void	Layout_SetupSceneCallbacks(LAYOUT* Layout,  LAYOUT_SCENE* LayoutScene, PROCESS_INSTANCE * Instance, vector4* Offset )
{	
	LAYOUT_SCENE_CALLBACK*    Callbacks;

	assert_pointer( Layout );
	assert_pointer( LayoutScene );

	//First call functions refered to in the layout file
	LAYOUT_SCENE_CALLBACK_FUNC* funcPtr = (LAYOUT_SCENE_CALLBACK_FUNC*)(LayoutScene->Callback.Func);
	if ( funcPtr!=null )
	{
		(*funcPtr)( {
			User        = (const void*)LayoutScene->Callback.Param,
			User2       = LayoutScene->Callback.Param2,
            UserList    = LayoutScene->Callback.UserList,
			LayoutScene = LayoutScene,
			Instance    = Instance,
            Offset      = Offset
		} );
	}

	Callbacks = Layout->SceneCallbacks;

	if ( Callbacks )
	{
		while ( Callbacks->Func )
		{
			if ( (u32)Callbacks->SceneNameHash == 0 || Callbacks->SceneNameHash == LayoutScene->NameHash )
			{
				( *Callbacks->Func )( { User		= Callbacks->Context,
                                        User2       = (LAYOUT_USERDATA)Callbacks->Context2,
                                        UserList    = Callbacks->UserList,
										LayoutScene	= LayoutScene,
										Instance	= Instance,
                                        Offset      = Offset
									  } );
			}
			Callbacks++;
		}
	}


}


//*****************************************************************************
//
//  Draw scene to the Z buffer only
//
//*****************************************************************************

static void LayoutScene_DrawZPrePass( LAYOUT_SCENE* LayoutScene )
{
	VCMATERIAL* Material;
	uint NumberOfMaterials;
	uint i;

	// Disable RGBA for prepass scene
	NumberOfMaterials = VCScene_GetNumberOfMaterials( LayoutScene->Scene );
	for ( i = 0; i < NumberOfMaterials; i++ )
	{
		Material = VCScene_GetMaterialByIndex( LayoutScene->Scene, i );
		VCMaterial_SetRedWriteEnable      ( Material, false );
		VCMaterial_SetGreenWriteEnable    ( Material, false );
		VCMaterial_SetBlueWriteEnable     ( Material, false );
		VCMaterial_SetAlphaWriteEnable    ( Material, false );
	}

	VCScene_Draw( LayoutScene->Scene );

	// Re-enable RGBA
	for ( i = 0; i < NumberOfMaterials; i++ )
	{
		Material = VCScene_GetMaterialByIndex( LayoutScene->Scene, i );
		VCMaterial_SetRedWriteEnable      ( Material, true );
		VCMaterial_SetGreenWriteEnable    ( Material, true );
		VCMaterial_SetBlueWriteEnable     ( Material, true );
		VCMaterial_SetAlphaWriteEnable    ( Material, true );
	}
}


//*****************************************************************************
//
//  Stretch the view to fit entire screen by assigning the source window to fit
//  the rectangle into which GUI objects are drawn
//
//*****************************************************************************

void Layout_StretchView( VCVIEW* View, bool usePerspective )
{
    VCVIEW_WINDOW SourceWindow;

    VCView_GetSourceWindow( View, &SourceWindow );

	if (usePerspective == false) {

		SourceWindow.TopLeftFront.set_x( -0.5 * GUI_SCREEN_WIDTH );
		SourceWindow.TopLeftFront.set_y( 0.5 * GUI_SCREEN_HEIGHT );
		SourceWindow.BottomRightBack.set_x(  0.5 * GUI_SCREEN_WIDTH );
		SourceWindow.BottomRightBack.set_y( -0.5 * GUI_SCREEN_HEIGHT );
	}

	// TLM: We actually don't want to stretch... we're going to add extra art outside
	// the 4:3 area for the 16:9 displays. Nothing important will be in this area.

	if (View_IsWideScreen()) {

		if (usePerspective == false) {

			// MPB - this used to just multiply the coordinates set above by 1.333, 
			// but that wasn't correct because 640/448 != 1.333
			SourceWindow.TopLeftFront.set_x( SourceWindow.BottomRightBack.get_y() * 16.0 / 9.0 );
			SourceWindow.BottomRightBack.set_x( SourceWindow.TopLeftFront.get_y() * 16.0 / 9.0 );

		} else {

			// the above isn't working for perspective just yet. to do.
		}
	}

	VCView_SetSourceWindow( View, &SourceWindow );
}


//*****************************************************************************
//
//  This function is so that outside code can draw scenes just like a layout does
//
//*****************************************************************************

void Layout_DrawSceneExternal( VCSCENE * Scene, const vector4* Offset, bool usePerspective ) {

	VCANIMATIONCAMERA * pCamera = null;
	VCVIEW              View;
	vector4             Position;
	vector4             TotalOffset;
	static const vector4    DefaultLightDirection[] = {
		vector4_create_raw(0, 0, 1, 0),	   // NOTE: directions are TOWARDS the light source
		vector4_create_raw(-1, 1, 0, 0),
		vector4_create_raw( 1, 1, 0, 0),
		vector4_create_raw(0, -1, -1, 0)
	};
	static const float      DefaultLightIntensity[] = { 1, 0.7, 0.7, 0.7};
	static const color      DefaultLightColor[] = {
		color_construct_argb(255, 255, 255, 255),
		color_construct_argb(255, 255, 255, 255),
		color_construct_argb(255, 255, 255, 255),
		color_construct_argb(255, 255, 255, 255)
	};

	VCVIEW_LIGHT        DefaultLight;
	uint                i;

	// Set up the view depending on camera type
	if ( usePerspective ) {

		// Use the scene's own camera and lights
		pCamera = VCScene_GetFirstAnimationCamera( Scene );
		assert_pointer( pCamera );
		View_InitPerspective( &View );
		Layout_StretchView( &View, true );
		View_SetSceneCameraAndLights( Scene, pCamera->Name, &View);
		//scene callbacks ( after the camera has been setup because the callbacks
		TotalOffset = vector4_create( 0, 0, 0, 1);

	} else {

		View_InitParallel( &View );

		Layout_StretchView( &View, false );

		// Position the camera in Maya coordinate space, and offset camera to position
		// the scene at the specified offset in the view
		TotalOffset = *Offset;
		vector4_negate( &Position, &TotalOffset );
		
		vector4 vec = vector4_create( 0,0,600,0);
		vector4_add( &Position, &Position, &vec);
		
		Position.set_w(1);
		TotalOffset.set_w(1);
		vector4 Cam1,Cam2,Cam3;
		vector4_construct(&Cam1,0,0,-1,0);
		vector4_construct(&Cam2,0,1,0,0);
		vector4_construct(&Cam3,1,0,0,0);
		VCView_SetCameraPositionAimUpAndRight( &View, &Position,&Cam1,&Cam2,&Cam3 );

		// default lights
		for ( i = 0; i < countof( DefaultLightDirection ); i++ ) {
			VCView_InitDirectionalLight(&DefaultLight, &DefaultLightDirection[ i ],
										DefaultLightColor[ i ],
										DefaultLightIntensity[ i ] );
			VCView_SetLight(&View, i, &DefaultLight);
		}
		VCView_SetNumberOfLights(&View, countof( DefaultLightDirection ) );
	}

	// set the view
	VCView_SetRenderState( &View );

	VCScene_Draw( Scene );
}


//*****************************************************************************
//
//  Draw one SPREADSHEET Object
//
//*****************************************************************************

#ifdef VCFETARGET
static void Layout_DrawSpreadSheet(LAYOUT_SPREADSHEET* SpreadSheet, const vector4* Offset)
{
	const float thick = 2.0;

	vector4             Position;
	VCVIEW              View;
	VCMATERIAL			Material;
	float				width = (float)SpreadSheet->Width;
	float				height = (float)SpreadSheet->Height;
	VCView_InitParallel( &View );


	Layout_StretchView( &View, false );
	VCView_SetCameraPositionAndAim( &View, {0,0,600,1}, {0,0,0,1} );
	vector4_add( &Position, &SpreadSheet->Offset, Offset );

	Position.y = -Position.y;
	if ( View_IsWideScreen() )
	{
		vector4_add( &Position, &Position, { -400, 0.5 * GUI_SCREEN_HEIGHT,0,0 } );
	} else
	{
		vector4_add( &Position, &Position, { -320, 0.5 * GUI_SCREEN_HEIGHT,0,0 } );
	}

	VCView_SetRenderState( &View );
	VCMaterial_Reset( &Material );
	VCMaterial_SetDepthCompareMode  ( &Material, ALWAYS );
	VCMaterial_SetCullMode( &Material, NONE);

    VCPrim_Begin( false , false , TRIANGLE_STRIP , &Material , null );
	VCPrim_AddVertex( {Position.x - thick,			Position.y + thick, Position.z, 1} );
	VCPrim_AddVertex( {Position.x,					Position.y, Position.z, 1} );
	VCPrim_AddVertex( {Position.x + width + thick,	Position.y + thick, Position.z, 1} );
	VCPrim_AddVertex( {Position.x + width,			Position.y, Position.z, 1} );
	VCPrim_AddVertex( {Position.x + width + thick,	Position.y - height - thick, Position.z, 1} );
	VCPrim_AddVertex( {Position.x + width,			Position.y - height, Position.z, 1} );
	VCPrim_AddVertex( {Position.x - thick,			Position.y - height - thick, Position.z, 1} );
	VCPrim_AddVertex( {Position.x,					Position.y - height, Position.z, 1} );
	VCPrim_AddVertex( {Position.x - thick,			Position.y + thick, Position.z, 1} );
	VCPrim_AddVertex( {Position.x,					Position.y, Position.z, 1} );
	VCPrim_End();
}
#endif

void Layout_SetupParallelView ( VCVIEW * View, const vector4 * Offset, bool SetupLights ) {

    vector4 Position = vector4_create( 0, 0, 0, 1 );
    static const vector4	DefaultLightDirection[] = {
		 vector4_create_raw(0, 0, 1, 0),		// NOTE: directions are TOWARDS the light source
		 vector4_create_raw(-1, 1, 0, 0),
		 vector4_create_raw( 1, 1, 0, 0),
		 vector4_create_raw(0, -1, -1, 0)
	};
	static const float		DefaultLightIntensity[] = { 1, 0.7, 0.7, 0.7 };
	static const color		DefaultLightColor[] = {
		color_construct_argb(255, 255, 255, 255),
		color_construct_argb(255, 255, 255, 255),
		color_construct_argb(255, 255, 255, 255),
		color_construct_argb(255, 255, 255, 255)
	};

	VCVIEW_LIGHT		DefaultLight;
	uint                i;


    View_InitParallel( View );

    Layout_StretchView( View, false );

    // Position the camera in Maya coordinate space, and offset camera to position
    // the scene at the specified offset in the view
    //vector4_add( &TotalOffset, &LayoutScene->Offset, Offset );
    //vector4_negate( &Position, &TotalOffset );
    vector4 vec = vector4_create( 0,0,600,0 );
    vector4_add( &Position, Offset, &vec );
    Position.set_w(1);
    //TotalOffset.w = 1;
    vector4 vAim = vector4_create( 0,0,-1,0 );
	vector4 vUp = vector4_create( 0,1,0,0 );
	vector4 vRight = vector4_create( 1,0,0,0 );
    VCView_SetCameraPositionAimUpAndRight( View, &Position, &vAim, &vUp, &vRight );

    //set front-end lighting
    if ( SetupLights )
    {
        // default lights
        for ( i = 0; i < countof( DefaultLightDirection ); i++ ) {
            VCView_InitDirectionalLight(&DefaultLight, &DefaultLightDirection[ i ],
                                                        DefaultLightColor[ i ],
                                                        DefaultLightIntensity[ i ] );
            VCView_SetLight(View, i, &DefaultLight);
        }
        VCView_SetNumberOfLights(View, countof( DefaultLightDirection ) );
    }
    else
    {
        VCVIEW_LIGHT		ZeroLight;

        // Clear out the lights before setting any
        // The light API ignores VCView_SetNumberOfLights(), so this is the only
        // way to ensure we don't get unwanted lights
        vector4 dir = vector4_create(0,0,0,0);
        VCView_InitDirectionalLight( &ZeroLight, &dir, {0,0,0,0}, 0 );
        for ( i = 0; i < VCVIEW_MAX_LIGHTS; i++ )
        {
            VCView_SetLight( View, i, &ZeroLight );
        }
    }
}


//*****************************************************************************
//
//  Draw one LAYOUT_SCENE object
//
//*****************************************************************************

static void Layout_DrawScene( LAYOUT* Layout, const void* LayoutContext, LAYOUT_SCENE* LayoutScene,
							  const vector4* Offset, bool useCurrentView, PROCESS_INSTANCE * Instance )
{
	VCANIMATIONCAMERA *	pCamera = null;
	VCVIEW              View;
	vector4             Position;
    vector4             TotalOffset;
	static const vector4	DefaultLightDirection[] = {
		 vector4_create_raw(0, 0, 1, 0),		// NOTE: directions are TOWARDS the light source
		 vector4_create_raw(-1, 1, 0, 0),
		 vector4_create_raw( 1, 1, 0, 0),
		 vector4_create_raw(0, -1, -1, 0)
	};
	static const float		DefaultLightIntensity[] = { 1, 0.7, 0.7, 0.7 };
	static const color		DefaultLightColor[] = {
		color_construct_argb(255, 255, 255, 255),
		color_construct_argb(255, 255, 255, 255),
		color_construct_argb(255, 255, 255, 255),
		color_construct_argb(255, 255, 255, 255)
	};

	VCVIEW_LIGHT		DefaultLight;
	uint                i;
		
	#if !defined( LAYOUTVIEWER ) && !defined( VCFETARGET )
	matrix				mat,oMat;
	#endif

	assert( LayoutScene->Type == SCENE );

	if ( LayoutScene->Enabled )
	{
		assert_pointer( LayoutScene->Scene );
	
		// Allow user to update texture through callbacks
		// (Called before animation update, in case a material component needs to be animated,
		// for example, the callback mayu change the rgb while the animation changed the alpha!)
		Layout_SetupSceneMaterials( Layout, LayoutContext, LayoutScene, Instance );
	
		// Update scene animation.  See Layout_Update() for explanation.
   		LayoutScene_Update( LayoutScene, Layout->DeltaTime );
	}

	if (!useCurrentView) {
	
		// Set up the view depending on camera type
		switch ( LayoutScene->Camera )
		{
			case PERSPECTIVE:
				// Use the scene's own camera and lights
				pCamera = VCScene_GetFirstAnimationCamera( LayoutScene->Scene );
#ifdef VCFETARGET	
				View_InitPerspective( &View );
				Layout_StretchView( &View, true );
				if (pCamera!=null)
				{
					View_SetCameraAndLights( LayoutScene->Scene, pCamera->Name, &View);
				} else
				{
					vector4 Position = vector4_create(0,0,600,1);
					vector4 aim = vector4_create(0,0,0,1);
					VCView_SetCameraPositionAndAim( &View, &Position , &aim);
				}
#else
				assert_pointer( pCamera );
				View_InitPerspective( &View );
				Layout_StretchView( &View, true );
				View_SetSceneCameraAndLights( LayoutScene->Scene, pCamera->Name, &View);
#endif				
                //scene callbacks ( after the camera has been setup because the callbacks
                TotalOffset = vector4_create( 0, 0, 0, 1 );
                Layout_SetupSceneCallbacks( Layout, LayoutScene, Instance, &TotalOffset );
				
                break;
			
			case ORTHOGRAPHIC:
	
				View_InitParallel( &View );

				Layout_StretchView( &View, false );

                // Position the camera in Maya coordinate space, and offset camera to position
				// the scene at the specified offset in the view
				vector4_add( &TotalOffset, &LayoutScene->Offset, Offset );
				vector4_negate( &Position, &TotalOffset );
				vector4 vec = vector4_create(0,0,600,0);
				vector4_add( &Position, &Position, &vec );
				Position.set_w(1);
                TotalOffset.set_w(1);
                vector4 Aim = vector4_create( 0,0,-1,0 );
                vector4 Up = vector4_create( 0,1,0,0 );
                vector4 Right = vector4_create( 1,0,0,0 );
				VCView_SetCameraPositionAimUpAndRight( &View, &Position, &Aim, &Up, &Right );
				
                // scene callbacks ( called after the view is setup so that the callback can also modify the view )
                //
                Layout_SetupSceneCallbacks( Layout, LayoutScene, Instance, &TotalOffset );

				//set front-end lighting
				if ( LayoutScene->UseSceneLights == DEFAULT || LayoutScene->UseSceneLights == FALSE )
				{
					// default lights
					for ( i = 0; i < countof( DefaultLightDirection ); i++ ) {
						VCView_InitDirectionalLight(&DefaultLight, &DefaultLightDirection[ i ],
																	DefaultLightColor[ i ],
																	DefaultLightIntensity[ i ] );
						VCView_SetLight(&View, i, &DefaultLight);
					}
					VCView_SetNumberOfLights(&View, countof( DefaultLightDirection ) );
				}
				else
				{
					VCVIEW_LIGHT		ZeroLight;
				
					// Clear out the lights before setting any
					// The light API ignores VCView_SetNumberOfLights(), so this is the only
					// way to ensure we don't get unwanted lights
					vector4 dir = vector4_create(0,0,0,0);
					VCView_InitDirectionalLight( &ZeroLight, &dir, {0,0,0,0}, 0 );
					for ( i = 0; i < VCVIEW_MAX_LIGHTS; i++ )
					{
						VCView_SetLight( &View, i, &ZeroLight );
					}

					VCScene_SetLights( LayoutScene->Scene, &View );
				}
	
				break;
		}

		// set the view
		VCView_SetRenderState( &View );

	} else {

        //scene callbacks
        TotalOffset = vector4_create( 0, 0, 0, 1 );
        Layout_SetupSceneCallbacks( Layout, LayoutScene, Instance, &TotalOffset );
		
        #if !defined( LAYOUTVIEWER ) && !defined( VCFETARGET )

		VCView_GetRenderState(  &View );
		VCView_GetCameraMatrix( &View, &mat );	// to modify
		VCView_GetCameraMatrix( &View, &oMat ); // original that we can restore

		vector4_add( &Position, &LayoutScene->Offset, Offset );
		matrix_pre_translate_xyz( &mat, Position.get_x(), Position.get_y(), Position.get_z() );

		VCView_SetCameraMatrix( &View, &mat );
		VCView_SetRenderState(  &View );

		#endif
	}

	// handle a callback disabling this scene
	if ( !LayoutScene->Enabled ) return;

	// Draw the scene.
	if ( LayoutScene->RenderZPrePass )
	{
		LayoutScene_DrawZPrePass( LayoutScene );
	}

	VCScene_Draw( LayoutScene->Scene );

	// Draw the text overlay
	if ( LayoutScene->IsMarkScene )
	{
		Layout_DrawSceneText       ( Layout, LayoutContext, LayoutScene, Instance );
		Layout_DrawSceneCustomNodes( Layout, LayoutScene, Instance );
	}

	// restore
	if (useCurrentView) {
		
		#if !defined( LAYOUTVIEWER )  && !defined( VCFETARGET )

		VCView_SetCameraMatrix( &View, &oMat );
		VCView_SetRenderState( &View );

		#endif
	}
}


//*****************************************************************************
//
//  Draw all of the layout's objects
//
//*****************************************************************************

static void Layout_DrawInternal( LAYOUT* Layout, const void* LayoutContext, const vector4* Offset, bool useCurrentView, PROCESS_INSTANCE * Instance )
{
	LAYOUT_OBJECT*   LayoutObject;
	VCVIEW           saved;
	LAYOUT_TEMPLATE* LayoutTemplate;
	vector4          TemplateOffset;

	assert_pointer( Layout );
	assert_message( Layout->Status == "initialized", "Layout is not initialized" );


	// if no context override is passed in, use the context that was used to
	// initialize this layout
	if ( LayoutContext == null )
	{
		LayoutContext = Layout->Context;
	}
	
	// save the view

	if (!useCurrentView) {
		VCView_GetRenderState( &saved );
	}

	//iterate through list of layout objects
	for( LayoutObject = Layout->ObjectList  ;  LayoutObject  ;  LayoutObject = LayoutObject->Next )
	{
		switch ( LayoutObject->Type )
		{
            case SCENE:
				Layout_DrawScene( Layout, LayoutContext, (LAYOUT_SCENE*) LayoutObject, Offset, useCurrentView, Instance );
				break;
			case SPREADSHEET:
#ifdef VCFETARGET
				Layout_DrawSpreadSheet((LAYOUT_SPREADSHEET*) LayoutObject, Offset);
#endif
				if ( Layout->DrawSpreadsheetCallback )
				{
					( *Layout->DrawSpreadsheetCallback )( { LayoutSpreadSheet = (LAYOUT_SPREADSHEET*) LayoutObject } );
				}
				break;
			case TEMPLATE:
				// Recursively draw the sub-layout
				LayoutTemplate = (LAYOUT_TEMPLATE*) LayoutObject;
				if ( LayoutTemplate->Layout )
				{
					vector4_add( &TemplateOffset, Offset, &LayoutTemplate->Offset );
					Layout_DrawInternal( LayoutTemplate->Layout, LayoutTemplate->Context, &TemplateOffset, useCurrentView, Instance );
				}
				break;
			case ANIMATION:
				break;

		}
	}

	// restore the view

	if (!useCurrentView) {
		VCView_SetRenderState( &saved );
	}

	// Zero out DeltaTime in case Layout_Draw() gets called before next Layout_Update()
		Layout->DeltaTime = 0.0;
}


//*****************************************************************************
//
//
//
//*****************************************************************************

void Layout_Draw( LAYOUT* Layout, PROCESS_INSTANCE * Instance )
{
	vector4 vec = vector4_create( 0,0,0,0 );
	Layout_DrawInternal( Layout, null, &vec, false, Instance );
}

//*****************************************************************************
//
//
//
//*****************************************************************************

void Layout_DrawWithOffset( LAYOUT* Layout, PROCESS_INSTANCE * Instance, const vector4 * Offset )
{
	Layout_DrawInternal( Layout, null, Offset, false, Instance );
}


//*****************************************************************************
//
//
//
//*****************************************************************************

void Layout_DrawWithCurrentView( LAYOUT* Layout, PROCESS_INSTANCE * Instance, const vector4 * Offset )
{
	Layout_DrawInternal( Layout, null, Offset, true, Instance );
}


//*****************************************************************************
//
// In VCFETarget all scenes are stored using mangled filenames to fit into 28 char limit
// of the file system
//
//*****************************************************************************

#ifdef VCFETARGET
static void Layout_FileNameToIffName(char* Path, char* SceneFilename,bool IsMarkScene)
{
	string_crc crc = (string_crc)VCChecksum_StringIgnoreCase(SceneFilename);
#ifdef WIN32DX
	if ( IsMarkScene )
	{
		VCString_Printf(Path,"DVD:%x_p_m.iff",(u32)crc);
	} else
	{
		VCString_Printf(Path,"DVD:%x_p.iff",(u32)crc);
	}
#else
	if ( IsMarkScene )
	{
		VCString_Printf(Path,"DBG:%x_p_m.iff",(u32)crc);
	} else
	{
		VCString_Printf(Path,"DBG:%x_p.iff",(u32)crc);
	}
#endif
#endif


//*****************************************************************************
//
// Resolving callbacks
//
//*****************************************************************************

static void Layout_ResolveCallback(CALLBACK_OBJECT* callbackObject)
{
	//TODO: Binary search
	assert_pointer(callbackObject);
	if ( !callbackObject->Func ) return;
	LAYOUT_FUNC_DEFINITION* funcTableItem = Layout_CallbackTable;
	while (funcTableItem->func)
	{
		if ( funcTableItem->crc == (string_crc)callbackObject->Func )
		{
#ifdef DEBUG
//			VCDebugMessage_Printf (null,"Resolved %x to %x\n",(u32)callbackObject->Func,(u32)funcTableItem->func);
#endif
			callbackObject->Func = (u32)funcTableItem->func;
			return;
		}
		funcTableItem++;
	}
#ifdef DEBUG
//	VCDebugMessage_Printf (null,"Cannot resolve %x\n",(u32)callbackObject->Func);
#endif
	callbackObject->Func = /*null*/0;
}


//*****************************************************************************
//
//
//
//*****************************************************************************

static void Layout_ResolveCallbackList(CALLBACK_OBJECT** ppItem)
{
	assert_pointer(ppItem);
	while( *ppItem!=null )
	{
#ifdef DEBUG
//		CALLBACK_OBJECT* obj = *ppItem;
//		VCDebugMessage_Printf (null,"%x->%x\n",(u32)obj->Item,(u32)obj->Func);
#endif
		Layout_ResolveCallback(*ppItem);
		ppItem = &((*ppItem)->Next);
	}
}


//*****************************************************************************
//
//
//
//*****************************************************************************

static void Layout_ResolveMaterials(LAYOUT_SCENE* LayoutScene)
{
	assert_pointer(LayoutScene);
	CALLBACK_OBJECT* obj = LayoutScene->MaterialCallback;
	VCSCENE* scene = LayoutScene->Scene;
	while ( obj!=null )
	{
		VCMATERIAL* Material = Layout_GetMaterialByNameCrc( scene, (string_crc)obj->Item );
#ifdef DEBUG
//		VCDebugMessage_Printf (null,"MATERIAL:%x->%x\n",(u32)obj->Item,(u32)Material);
#endif
		obj->Item = (u32)Material;
		obj = obj->Next;
	}
}


//*****************************************************************************
//
//
//
//*****************************************************************************

static void Layout_ResolveTexts(LAYOUT_SCENE* scene)
{
	unused(scene);
#if 0
	assert_pointer(scene);
	if ( !scene->IsMarkScene ) return;
	MARKSCENE* MarkScene = scene->MarkScene;
	CALLBACK_OBJECT* obj = scene->TextCallback;
	while ( obj!=null )
	{
		const MARKSCENETEXT* text = MarkScene_GetTextByLabelHash( MarkScene, (string_crc)obj->Item );
#ifdef DEBUG
//		VCDebugMessage_Printf (null,"TEXT:%x->%x\n",(u32)obj->Item,(u32)text);
#endif

		obj->Item = (u32)text;
		obj = obj->Next;
	}
#endif
}


//*****************************************************************************
//
//
//
//*****************************************************************************

static void Layout_ResolveLocators(LAYOUT_SCENE* scene)
{
	assert_pointer(scene);
	if ( !scene->IsMarkScene ) return;
	MARKSCENE* MarkScene = scene->MarkScene;

	CALLBACK_OBJECT* obj = scene->LocatorCallback;
	while ( obj!=null )
	{
		const MARKSCENENODE* lc = MarkScene_GetLocatorByLabelHash( MarkScene, (string_crc)obj->Item );
#ifdef DEBUG
//		VCDebugMessage_Printf (null,"LOCATOR:%x->%x\n",(u32)obj->Item,(u32)lc);
#endif

		obj->Item = (u32)lc;
		obj = obj->Next;
	}
}

//*****************************************************************************
//
//
//
//*****************************************************************************
static void Layout_ResolveBoneModifiers(LAYOUT_SCENE* scene)
{
	if ( scene->BoneModifierList == null ) return;

	u8* BoneModifierRaw = (u8*)scene->BoneModifierList;
	for ( uint i = 0 ; i < scene->BoneModifierCount; i++, BoneModifierRaw+=sizeof(LAYOUT_BONE_MODIFIER) )
	{
		BoneModifierRaw = alignup(BoneModifierRaw,alignof(LAYOUT_BONE_MODIFIER));
		LAYOUT_BONE_MODIFIER* BoneModifier = (LAYOUT_BONE_MODIFIER*)BoneModifierRaw;
		//VCDebugMessage_Printf (null,"BONE:%x:%x:%x [%f,%f]\n",
		//	(u32)BoneModifier->SceneNameHash,
		//	(u32)BoneModifier->ObjectNameHash,
		//	(u32)BoneModifier->NodeNameHash,
		//	BoneModifier->Offset.x,
		//	BoneModifier->Offset.y
		//	);
		
		VCSCENE* vcscene = scene->Scene;
		if ( scene->IsMarkScene && scene->MarkScene!=null )
		{
			vcscene = scene->MarkScene->VCScene;
		}
		// Defensive programming
		if ( scene == null )
		{
			//VCDebugMessage_Printf( null, __locale__( text, 13068, "BONE: NULL scene!\n" ));
			continue;
		}
		
		//mark bone-modifier as erroneous by default
		BoneModifier->SceneNameHash = (string_crc)0;

		VCOBJECT* SceneObject = VCScene_GetObjectByNameCrc(vcscene, BoneModifier->ObjectNameHash);
		if ( SceneObject==null )
		{
			//VCDebugMessage_Printf( null, __locale__( text, 13069, "BONE: Cannot find object with hash=%x!\n" ),(u32)BoneModifier->ObjectNameHash);
			continue;
		}

		//VCDebugMessage_Printf(__locale__( text, 13070, "BONE: Found Object %s\n" ),SceneObject->Name);

		VCMODEL* SceneModel = VCObject_GetModel(SceneObject);
		if ( SceneModel == null )
		{
			//VCDebugMessage_Printf( null, __locale__( text, 13071, "BONE: NULL Model\n" ));
			continue;
		}
		//VCDebugMessage_Printf(__locale__( text, 13072, "BONE: Found Object %s Model %s\n" ),SceneObject->Name, VCModel_GetName( SceneModel ) );

		const VCMODEL_NODE* ModelNode = VCModel_GetFirstNode(SceneModel);
		while (ModelNode!=null)
		{
			if ( VCChecksum_String(VCModel_GetNodeName( ModelNode )) == BoneModifier->NodeNameHash ) break;
			ModelNode = VCModel_GetNextNode(SceneModel,ModelNode);
		}

		if ( ModelNode == null )
		{
			//VCDebugMessage_Printf( null, __locale__( text, 13073, "BONE: Cannot find model with hash=%x!\n" ),(u32)BoneModifier->NodeNameHash);
			continue;
		}

		matrix * MatrixList = VCObject_GetMatrixList( SceneObject );
		uint index = VCModel_GetNodeMatrixIndex( SceneModel , ModelNode );
		//VCDebugMessage_Printf(__locale__( text, 13074, "BONE: Found ModelNode %s Index %d\n" ),VCModel_GetNodeName( ModelNode ), index);

		matrix* BoneMatrix = MatrixList + index;
		
		//Store pointer to the matrix for later use
		*((matrix**)&BoneModifier->SceneNameHash)=BoneMatrix;
		//Since we don't use z and w offsets, we can (ab)use them to store backup copies of x and y bone translations
		//that we are going to mangle during Updates
		BoneModifier->Offset.set_z( BoneMatrix->tx );
		BoneModifier->Offset.set_w( BoneMatrix->ty );
		//mark bone-modifier as valid
		BoneModifier->ObjectNameHash = (string_crc)0;
	}
}

//*****************************************************************************
//
//  Initialize Layout object
//
//*****************************************************************************

void Layout_Init( LAYOUT* Layout, LAYOUT_INIT* LayoutInit )
{
	LAYOUT_OBJECT*    LayoutObject;
	LAYOUT_SCENE*     LayoutScene;
	LAYOUT_TEMPLATE*  LayoutTemplate;

#ifdef VCFETARGET
	char Path[MAX_PATH];
	bool Result;
	LAYOUT_RESOURCE*  ResourceObject;
#endif

	if ( LayoutInit )
	{
		Layout->DynamicText      = LayoutInit->DynamicText;
		Layout->CustomDrawNodes  = LayoutInit->CustomDrawNodes;
		Layout->DynamicMaterials = LayoutInit->DynamicMaterials;
		Layout->SceneCallbacks 	 = LayoutInit->SceneCallbacks;
	}
	else
	{
		Layout->DynamicText      = null;
		Layout->CustomDrawNodes  = null;
		Layout->DynamicMaterials = null;
		Layout->SceneCallbacks 	 = null;
	}

#ifdef VCFETARGET
	//In VCFETarget we have to autoload all resources
	if ( LayoutData.Resource==null )
	{
		LayoutData.Resource = VCHeap_Allocate( VCLibrary_GetGlobalHeap(), sizeof(LAYOUT_RESOURCE) );
		VCList_Init(LayoutData.Resource,Prev,Next);
	}
#endif

	Layout->DeltaTime = 0;

	//iterate through list of layout objects
	for( LayoutObject = Layout->ObjectList  ;  LayoutObject  ;  LayoutObject = LayoutObject->Next )
	{
		switch ( LayoutObject->Type )
		{
			case SCENE:
				LayoutScene = (LAYOUT_SCENE*) LayoutObject;
#ifdef VCFETARGET
				//In VCFETarget we have to load all scenes right away
				Layout_FileNameToIffName(Path, LayoutScene->SceneFilename,LayoutScene->IsMarkScene);
				ResourceObject = VCHeap_Allocate( VCResource_GetHeap(), sizeof(LAYOUT_RESOURCE) );
				if ( ResourceObject==null ) break;
				ResourceObject->Prev = ResourceObject->Next = null;

				Result = VCResource_CreateContext(LayoutScene->SceneFilename,Path,&(ResourceObject->Context));
				if ( !Result ) continue;
				VCResource_BlockUntilLoadCompleted();
				VCList_Append(LayoutData.Resource,ResourceObject,Prev,Next);
#endif

				if ( LayoutScene->IsMarkScene ) {
					LayoutScene->MarkScene        = VCResource_GetObject( null, MARKSCENE_RESOURCE_TYPE, LayoutScene->SceneFilename );
					LayoutScene->Scene            = ( LayoutScene->MarkScene ) ? MarkScene_GetVCScene( LayoutScene->MarkScene ) : null;
				}
				else {
					LayoutScene->Scene            = VCResource_GetObject( null, VCSCENE_RESOURCE_TYPE, LayoutScene->SceneFilename );
					LayoutScene->MarkScene        = null;
					LayoutScene->TextCallback     = null;
					LayoutScene->LocatorCallback  = null;
				}

				if ( LayoutScene->Scene == null ) {

					LayoutScene->Enabled = false;

				} else {
				
					LayoutScene->Enabled = true;

					LayoutScene->StartTime = VCScene_GetStartTimeInSeconds( LayoutScene->Scene );
					LayoutScene->EndTime   = VCScene_GetEndTimeInSeconds  ( LayoutScene->Scene );

					VCScene_SetLooping ( LayoutScene->Scene, LayoutScene->AnimationMode == LOOPING );
					LayoutScene_SetTime( LayoutScene, LayoutScene->AnimTimeInit );
					
					LayoutScene->Time = VCScene_GetTimeInSeconds( LayoutScene->Scene );
				}

				//VCDebugMessage_Printf (null,"Layout_ResolveCallback(&LayoutScene->Callback)\n");
				Layout_ResolveCallback(&LayoutScene->Callback);
				//VCDebugMessage_Printf (null,"Layout_ResolveCallbackList(&LayoutScene->MaterialCallback)\n");
				Layout_ResolveCallbackList(&LayoutScene->MaterialCallback);
				Layout_ResolveMaterials(LayoutScene);

				if ( LayoutScene->IsMarkScene )
				{
					//VCDebugMessage_Printf (null,"Layout_ResolveCallbackList(&LayoutScene->TextCallback);\n");
					Layout_ResolveCallbackList(&LayoutScene->TextCallback);
					Layout_ResolveTexts(LayoutScene);
					//VCDebugMessage_Printf (null,"Layout_ResolveCallbackList(&LayoutScene->LocatorCallback)\n");
					Layout_ResolveCallbackList(&LayoutScene->LocatorCallback);
					Layout_ResolveLocators(LayoutScene);
				}

				Layout_ResolveBoneModifiers(LayoutScene);

				break;
			case SPREADSHEET:
				break;
			case TEMPLATE:
				//bind template object to the template layout
				LayoutTemplate = (LAYOUT_TEMPLATE*) LayoutObject;
#ifdef VCFETARGET				//Load the layout
#ifdef WIN32DX
				VCString_Copy(Path,__locale__( text, 13075, "DVD:" ));
#else
				VCString_Copy(Path,__locale__( text, 13076, "DBG:" ));
#endif
				VCString_Append(Path,LayoutTemplate->TemplateFilename);
				VCString_Append(Path,__locale__( text, 13077, ".iff" ));

				ResourceObject = VCHeap_Allocate( VCResource_GetHeap(), sizeof(LAYOUT_RESOURCE) );
				if ( ResourceObject==null ) break;
				ResourceObject->Prev = ResourceObject->Next = null;
				VCList_Append(LayoutData.Resource,ResourceObject,Prev,Next);

				Result = VCResource_CreateContext(LayoutTemplate->TemplateFilename,Path,&(ResourceObject->Context));
				if ( !Result ) break;
				VCResource_BlockUntilLoadCompleted();

				LayoutTemplate->Layout  = VCResource_GetObject( null, LAYOUT_RESOURCE_TYPE, LayoutTemplate->TemplateFilename );
				LayoutTemplate->Context = null;
				Layout_Init(LayoutTemplate->Layout,null);
#else
				LayoutTemplate->Layout  = VCResource_GetObject( null, LAYOUT_RESOURCE_TYPE, LayoutTemplate->TemplateFilename );
				LayoutTemplate->Context = null;
#endif
				break;
			case ANIMATION:
				break;
		}
	}

	// update our status

	Layout->Status = "initialized";
}


//*****************************************************************************
//
//  Deinitialize Layout object ( currently here for posterity )
//
//*****************************************************************************

void Layout_Deinit( LAYOUT* Layout ) {
#ifdef VCFETARGET
	unused( Layout );
	if ( LayoutData.Resource==null ) return;

	LAYOUT_RESOURCE* Resource = null;
	LAYOUT_RESOURCE* NextResource = null;

	for( Resource = VCList_GetFirst( LayoutData.Resource, Prev, Next ) ;
		 !VCList_IsEndOfList( LayoutData.Resource, Resource );
		 Resource = NextResource )
	{
		NextResource = VCList_GetNext( Resource , Prev , Next );
		VCResource_DestroyContext(Resource->Context.Name);
		VCList_Remove( Resource, Prev, Next );
		VCHeap_Free(Resource);
	}
#else
	unused( Layout );
#endif
}

